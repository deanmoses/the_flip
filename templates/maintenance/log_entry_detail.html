{% extends "base.html" %}
{% load static core_extras %}
{% block title %}Edit Log Entry · {{ block.super }}{% endblock %}
{% block content %}
  <section>
    <nav class="page-header">
      <div class="page-header__left breadcrumb">
        <a href="{% url 'maintainer-machine-list' %}">Machines</a>
        <span>›</span>
        <a href="{% url 'maintainer-machine-detail' entry.machine.slug %}">{{ entry.machine.display_name }}</a>
        {% if entry.problem_report %}
          <span>›</span>
          <a href="{% url 'machine-problem-reports' entry.machine.slug %}">Problem Reports</a>
          <span>›</span>
          <a href="{% url 'problem-report-detail' entry.problem_report.pk %}">{{ entry.problem_report.created_at|smart_date }}</a>
        {% else %}
          <span>›</span>
          <a href="{% url 'log-machine' entry.machine.slug %}">Logs</a>
        {% endif %}
        <span>›</span>
        <strong>Edit Log Entry</strong>
      </div>
    </nav>
    <h2>Edit Log Entry</h2>
    {% if entry.problem_report %}
      <section class="flip-card">
        <div class="flip-card__top log-entry-meta">
          <div>Problem Report</div>
          {% if entry.problem_report.reporter_display %}
            <div class="flip-card__top-right">
              <strong>{{ entry.problem_report.created_at|smart_date }}</strong> by {{ entry.problem_report.reporter_display }}
            </div>
          {% endif %}
        </div>
        <div class="flip-card__main">
          {% if entry.problem_report.problem_type != entry.problem_report.PROBLEM_OTHER %}
            <p>{{ entry.problem_report.get_problem_type_display }}</p>
          {% endif %}
          {% if entry.problem_report.description %}<p>{{ entry.problem_report.description }}</p>{% endif %}
        </div>
      </section>
    {% endif %}
    <section class="card">
      <div class="form-container">
        <div class="form-field">
          <label for="work-date">Date of work</label>
          <input type="datetime-local"
                 id="work-date"
                 data-utc="{{ entry.work_date.isoformat }}"
                 data-entry-id="{{ entry.pk }}">
          <div id="work-date-status" class="status-indicator"></div>
        </div>
        <div class="form-field">
          <label for="maintainer-names">Maintainer name(s)</label>
          <div class="autocomplete" id="maintainer-autocomplete">
            <input type="text"
                   id="maintainer-names"
                   value="{% if entry.maintainers.all %}{{ entry.maintainers.all|join:", " }}{% elif entry.maintainer_names %}{{ entry.maintainer_names }}{% endif %}"
                   placeholder="Name(s), comma separated"
                   autocomplete="off"
                   data-1p-ignore="true"
                   data-lpignore="true">
            <div class="autocomplete__dropdown hidden" id="maintainer-dropdown"></div>
          </div>
          <div id="maintainer-save-indicator" class="status-indicator"></div>
        </div>
        <div class="entry-content">
          <div class="entry-text-container">
            <div class="entry-panel__header">
              <h3 class="entry-panel__title">Description</h3>
              <div>
                <button type="button" id="edit-button" class="btn btn-secondary">Edit</button>
                <div id="edit-actions-header" class="hidden">
                  <button type="button" id="save-button" class="btn btn-primary">Save</button>
                  <button type="button" id="cancel-button" class="btn btn-secondary">Cancel</button>
                </div>
                <div id="save-status" class="status-indicator"></div>
              </div>
            </div>
            <div class="entry-panel">
              <div id="text-view-mode">
                <div id="entry-text-display" class="markdown-content">{{ entry.text|render_markdown }}</div>
              </div>
              <div id="text-edit-mode" class="hidden">
                <textarea id="entry-text"
                          class="entry-text-edit"
                          data-entry-id="{{ entry.pk }}">{{ entry.text }}</textarea>
              </div>
            </div>
          </div>
          <div class="entry-text-container">
            <div class="entry-panel__header">
              <h3 class="entry-panel__title">Media</h3>
              <div>
                <button type="button" id="upload-button" class="btn btn-secondary">Upload Photos</button>
              </div>
            </div>
            <div class="entry-panel">
              <div id="media-container" class="media-grid">
                {% if entry.media.all %}
                  {% for media in entry.media.all %}
                    <div class="media-item" data-media-id="{{ media.id }}">
                      {% if media.media_type == 'video' %}
                        {% if media.transcode_status == 'ready' and media.transcoded_file %}
                          <video controls poster="{{ media.poster_file.url }}" class="media-video">
                            <source src="{{ media.transcoded_file.url }}" type="video/mp4">
                            Your browser doesn't support video playback.
                          </video>
                        {% elif media.transcode_status == 'processing' or media.transcode_status == 'pending' %}
                          <div class="media-status">Processing video…</div>
                        {% else %}
                          <div class="media-status error">Video processing failed.</div>
                        {% endif %}
                      {% else %}
                        <a href="{{ media.file.url }}" target="_blank" class="media-link">
                          {% if media.thumbnail_file %}
                            <img src="{{ media.thumbnail_file.url }}" alt="Log entry photo">
                          {% else %}
                            <img src="{{ media.file.url }}" alt="Log entry photo">
                          {% endif %}
                        </a>
                      {% endif %}
                      <button type="button"
                              class="btn-delete-media"
                              data-media-id="{{ media.id }}"
                              aria-label="Delete media">×</button>
                    </div>
                  {% endfor %}
                {% else %}
                  <p class="text-muted">No media.</p>
                {% endif %}
              </div>
              <div class="media-upload">
                <input type="file"
                       id="media-upload"
                       accept="image/*,video/*,.heic,.heif,image/heic,image/heif"
                       multiple
                       class="hidden">
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </section>
{% endblock %}
{% block extra_scripts %}
  <script>
      const ENTRY_ID = {{ entry.pk }};
      const CSRF_TOKEN = '{{ csrf_token }}';

      // Helper: format Date as datetime-local value (YYYY-MM-DDTHH:MM)
      function toDateTimeLocalValue(date) {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          const hours = String(date.getHours()).padStart(2, '0');
          const minutes = String(date.getMinutes()).padStart(2, '0');
          return `${year}-${month}-${day}T${hours}:${minutes}`;
      }

      // Auto-save work_date
      const workDateInput = document.getElementById('work-date');
      const workDateStatus = document.getElementById('work-date-status');

      // On page load: convert UTC to browser local time
      const utcDateStr = workDateInput.dataset.utc;
      if (utcDateStr) {
          const utcDate = new Date(utcDateStr);
          workDateInput.value = toDateTimeLocalValue(utcDate);
      }

      workDateInput.addEventListener('change', async () => {
          workDateStatus.textContent = 'Saving...';
          workDateStatus.className = 'status-indicator saving';

          try {
              // Get timezone offset in minutes (negative for ahead of UTC)
              const tzOffsetMinutes = new Date().getTimezoneOffset();

              const formData = new FormData();
              formData.append('action', 'update_work_date');
              formData.append('work_date', workDateInput.value);
              formData.append('tz_offset', tzOffsetMinutes);
              formData.append('csrfmiddlewaretoken', CSRF_TOKEN);

              const response = await fetch(window.location.href, {
                  method: 'POST',
                  body: formData
              });

              const data = await response.json();
              if (response.ok && data.success) {
                  workDateStatus.textContent = 'Saved';
                  workDateStatus.className = 'status-indicator saved';
                  setTimeout(() => {
                      workDateStatus.textContent = '';
                      workDateStatus.className = 'status-indicator';
                  }, 2000);
              } else {
                  workDateStatus.textContent = data.error || 'Error saving';
                  workDateStatus.className = 'status-indicator error';
              }
          } catch (error) {
              console.error('Save error:', error);
              workDateStatus.textContent = 'Error saving';
              workDateStatus.className = 'status-indicator error';
          }
      });

      // Text edit mode switching
      const textarea = document.getElementById('entry-text');
      const saveStatus = document.getElementById('save-status');
      const textViewMode = document.getElementById('text-view-mode');
      const textEditMode = document.getElementById('text-edit-mode');
      const editButton = document.getElementById('edit-button');
      const headerActions = document.getElementById('edit-actions-header');
      const saveButton = document.getElementById('save-button');
      const cancelButton = document.getElementById('cancel-button');
      const textDisplay = document.getElementById('entry-text-display');

      let originalText = textarea.value;

      function setTextareaHeight() {
          if (!textarea) return;
          textarea.style.height = 'auto';
          textarea.style.height = `${textarea.scrollHeight}px`;
          textarea.style.overflowY = 'hidden';
      }

      editButton.addEventListener('click', () => {
          originalText = textarea.value;
          textViewMode.classList.add('hidden');
          textEditMode.classList.remove('hidden');
          textarea.focus();
          editButton.classList.add('hidden');
          headerActions.classList.remove('hidden');
          // Grow the textarea to fit existing content on first show
          setTextareaHeight();
          // If styles need a tick to apply, adjust once more
          requestAnimationFrame(setTextareaHeight);
      });

      textarea.addEventListener('input', setTextareaHeight);

      cancelButton.addEventListener('click', () => {
          textarea.value = originalText;
          saveStatus.textContent = '';
          saveStatus.className = 'status-indicator';
          textEditMode.classList.add('hidden');
          textViewMode.classList.remove('hidden');
          headerActions.classList.add('hidden');
          editButton.classList.remove('hidden');
      });

      saveButton.addEventListener('click', async () => {
          saveStatus.textContent = 'Saving...';
          saveStatus.className = 'status-indicator saving';

          try {
              const formData = new FormData();
              formData.append('action', 'update_text');
              formData.append('text', textarea.value);
              formData.append('csrfmiddlewaretoken', CSRF_TOKEN);

              const response = await fetch(window.location.href, {
                  method: 'POST',
                  body: formData
              });

              if (response.ok) {
                  // Reload page to get server-rendered markdown
                  window.location.reload();
              } else {
                  saveStatus.textContent = 'Error saving';
                  saveStatus.className = 'status-indicator error';
              }
          } catch (error) {
              console.error('Save error:', error);
              saveStatus.textContent = 'Error saving';
              saveStatus.className = 'status-indicator error';
          }
      });

      // Upload media
      const uploadButton = document.getElementById('upload-button');
      const mediaInput = document.getElementById('media-upload');
      const existingMediaCount = document.querySelectorAll('#media-container .media-item').length;
      if (uploadButton && existingMediaCount > 0) {
          uploadButton.textContent = 'Upload More Photos';
      }
      if (uploadButton && mediaInput) {
          uploadButton.addEventListener('click', () => mediaInput.click());
      }
      const maintainerInput = document.getElementById('maintainer-names');
      const maintainerStatus = document.getElementById('maintainer-save-indicator');
      const maintainerDropdown = document.getElementById('maintainer-dropdown');
      let maintainers = [];
      let activeMaintainerIndex = -1;

      mediaInput.addEventListener('change', async (e) => {
          if (!e.target.files || !e.target.files.length) return;

          const files = Array.from(e.target.files);

          for (const file of files) {
              const formData = new FormData();
              formData.append('action', 'upload_media');
              formData.append('file', file);
              formData.append('csrfmiddlewaretoken', CSRF_TOKEN);

              try {
                  const response = await fetch(window.location.href, {
                      method: 'POST',
                      body: formData
                  });

                  const data = await response.json();
                  if (data.success) {
                      // Add new media to the grid
                      const mediaContainer = document.getElementById('media-container');
                      const mediaItem = document.createElement('div');
                      mediaItem.className = 'media-item';
                      mediaItem.dataset.mediaId = data.media_id;
                      let content = '';
                      if (data.media_type === 'video') {
                          if (data.transcode_status === 'ready' && data.media_url) {
                              const posterAttr = data.poster_url ? ` poster="${data.poster_url}"` : '';
                              content = `
                <video controls${posterAttr} class="media-video">
                  <source src="${data.media_url}" type="video/mp4">
                  Your browser doesn't support video playback.
                </video>
              `;
                          } else if (data.transcode_status === 'failed') {
                              content = `<div class="media-status error">Video processing failed.</div>`;
                          } else {
                              content = `<div class="media-status">Processing video…</div>`;
                          }
                      } else {
                          content = `
              <a href="${data.media_url}" target="_blank" class="media-link">
                <img src="${data.thumbnail_url}" alt="Log entry photo">
              </a>
            `;
                      }
                      mediaItem.innerHTML = `
            ${content}
            <button type="button" class="btn-delete-media" data-media-id="${data.media_id}" aria-label="Delete media">×</button>
          `;
                      mediaContainer.appendChild(mediaItem);

                      // Attach delete handler to new button
                      attachDeleteHandler(mediaItem.querySelector('.btn-delete-media'));
                      uploadButton.textContent = 'Upload More Photos';
                  } else {
                      alert('Failed to upload media: ' + (data.error || 'Unknown error'));
                  }
              } catch (error) {
                  console.error('Upload error:', error);
                  alert('Failed to upload media');
              }
          }

          // Reset input
          e.target.value = '';
      });

      // Delete media
      function attachDeleteHandler(button) {
          button.addEventListener('click', async () => {
              const mediaId = button.dataset.mediaId;
              const formData = new FormData();
              formData.append('action', 'delete_media');
              formData.append('media_id', mediaId);
              formData.append('csrfmiddlewaretoken', CSRF_TOKEN);

              try {
                  const response = await fetch(window.location.href, {
                      method: 'POST',
                      body: formData
                  });

                  if (response.ok) {
                      // Remove from DOM
                      const mediaItem = button.closest('.media-item');
                      mediaItem.remove();
                  } else {
                      alert('Failed to delete media');
                  }
              } catch (error) {
                  console.error('Delete error:', error);
                  alert('Failed to delete media');
              }
          });
      }

      // Attach delete handlers to existing media
      document.querySelectorAll('.btn-delete-media').forEach(attachDeleteHandler);

      async function saveMaintainers() {
          if (!maintainerInput || !maintainerStatus) return;
          maintainerStatus.textContent = 'Saving...';
          maintainerStatus.className = 'status-indicator saving';

          try {
              const formData = new FormData();
              formData.append('action', 'update_maintainers');
              formData.append('maintainers', maintainerInput.value);
              formData.append('csrfmiddlewaretoken', CSRF_TOKEN);

              const response = await fetch(window.location.href, {
                  method: 'POST',
                  body: formData
              });

              const data = await response.json();
              if (response.ok && data.success) {
                  maintainerStatus.textContent = 'Saved';
                  maintainerStatus.className = 'status-indicator saved';
                  setTimeout(() => {
                      maintainerStatus.textContent = '';
                      maintainerStatus.className = 'status-indicator';
                  }, 2000);
              } else {
                  maintainerStatus.textContent = data.error || 'Error';
                  maintainerStatus.className = 'status-indicator error';
              }
          } catch (error) {
              console.error('Save error:', error);
              maintainerStatus.textContent = 'Error';
              maintainerStatus.className = 'status-indicator error';
          }
      }

      function formatMaintainer(m) {
          if (m.display_name === m.username) {
              return m.username;
          }
          return `${m.display_name} (${m.username})`;
      }

      function filterMaintainers(query) {
          const q = query.toLowerCase().trim();
          if (!q) return maintainers;
          return maintainers.filter(m =>
              m.first_name.toLowerCase().startsWith(q) ||
              m.last_name.toLowerCase().startsWith(q) ||
              m.username.toLowerCase().startsWith(q)
          );
      }

      function showMaintainerDropdown(filtered) {
          if (!maintainerDropdown) return;
          if (!filtered.length) {
              maintainerDropdown.classList.add('hidden');
              return;
          }
          maintainerDropdown.innerHTML = filtered.map((m, i) =>
              `<div class="autocomplete__item${i === activeMaintainerIndex ? ' autocomplete__item-active' : ''}" data-index="${i}" data-username="${m.username}">${formatMaintainer(m)}</div>`
          ).join('');
          maintainerDropdown.classList.remove('hidden');
      }

      function hideMaintainerDropdown() {
          if (maintainerDropdown) {
              maintainerDropdown.classList.add('hidden');
          }
          activeMaintainerIndex = -1;
      }

      function attachMaintainerAutocomplete() {
          if (!maintainerInput || !maintainerDropdown) return;

          fetch('{% url "api-maintainer-autocomplete" %}')
              .then(response => response.json())
              .then(data => { maintainers = data.maintainers || []; })
              .catch(() => { maintainers = []; });

          maintainerInput.addEventListener('focus', () => {
              const filtered = filterMaintainers(maintainerInput.value);
              showMaintainerDropdown(filtered);
          });

          maintainerInput.addEventListener('input', () => {
              activeMaintainerIndex = -1;
              const filtered = filterMaintainers(maintainerInput.value);
              showMaintainerDropdown(filtered);
          });

          maintainerInput.addEventListener('keydown', (e) => {
              const filtered = filterMaintainers(maintainerInput.value);
              if (!filtered.length || maintainerDropdown.classList.contains('hidden')) return;

              if (e.key === 'ArrowDown') {
                  e.preventDefault();
                  activeMaintainerIndex = Math.min(activeMaintainerIndex + 1, filtered.length - 1);
                  showMaintainerDropdown(filtered);
              } else if (e.key === 'ArrowUp') {
                  e.preventDefault();
                  activeMaintainerIndex = Math.max(activeMaintainerIndex - 1, 0);
                  showMaintainerDropdown(filtered);
              } else if (e.key === 'Enter' && activeMaintainerIndex >= 0) {
                  e.preventDefault();
                  maintainerInput.value = filterMaintainers(maintainerInput.value)[activeMaintainerIndex].display_name;
                  hideMaintainerDropdown();
                  saveMaintainers();
              }
          });

          document.addEventListener('click', (e) => {
              if (maintainerDropdown && maintainerDropdown.contains(e.target)) {
                  const item = e.target.closest('.autocomplete__item');
                  if (item) {
                      const idx = Number(item.dataset.index);
                      const filtered = filterMaintainers(maintainerInput.value);
                      maintainerInput.value = filtered[idx]?.display_name || '';
                      saveMaintainers();
                  }
                  hideMaintainerDropdown();
              } else if (maintainerDropdown && !maintainerInput.contains(e.target)) {
                  hideMaintainerDropdown();
              }
          });
      }

      if (maintainerInput) {
          maintainerInput.addEventListener('change', saveMaintainers);
          maintainerInput.addEventListener('blur', () => {
              saveMaintainers();
          });
          maintainerInput.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') {
                  e.preventDefault();
                  saveMaintainers();
              }
          });
          attachMaintainerAutocomplete();
      }
  </script>
{% endblock %}
